<!DOCTYPE HTML>
<html>
<head>
	<title>Dead Maze Map</title>
	<link rel="icon" href="/favicon.ico" />
	<meta charset="UTF-8">
	
	<meta name="author" content="Fewfre" />
	<meta name="flattr:id" content="x29v5q">
	
	<script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script>
	
	<style>
		html, body {
			background: #003816;
			margin: 0;
			padding: 0;
			width:100%;
			height:100%;
			line-height: 0;
		}
		/* canvas {
			border: 1px solid darkgreen;
		} */
	</style>
</head>
<body>
	<canvas id="map" width="800" height="450"></canvas>

<script src="core.js"></script>
<script>
(function(){
	
"use strict";
let canvas = document.querySelector("#map"), ctx = canvas.getContext("2d");
canvas.width = document.body.clientWidth; canvas.height = document.body.clientHeight;
let STAGE_WIDTH = canvas.width, STAGE_HEIGHT = canvas.height;
let STAGE_CENTER_X = canvas.width*0.5, STAGE_CENTER_Y = canvas.height*0.5;
let TILE_WIDTH = 82, TILE_HEIGHT = 42, TILE_DIAG = 46.07, TILE_ANGLE = -27.121, TILE_ANGLE2 = -90-(90+TILE_ANGLE);
let DEG2RAD = Math.PI/180, RAD2DEG = 180/Math.PI;
let assets, spriteManager;
let curScreen;

function main() {
	assets = new AssetManager();
	spriteManager = new SpriteManager();
	curScreen = new PreloadScreen();
	
	// Preload
	assets.load([
		"http://fewfre.com/images/avatar.jpg?tag=fortdress&ref="+encodeURIComponent(document.referrer),
		"http://www.transformice.com/images/x_deadmeat/x_interfaces/qualite_0.png",
	], _onInitialLoad);
	
	window.requestAnimationFrame(update);
}

function _onInitialLoad() {
	assets.load([
		{ id:"sac_icon", src:"http://www.transformice.com/images/x_deadmeat/x_interfaces/monde/zones/38.png" },
		{ id:"bodega_icon", src:"http://www.transformice.com/images/x_deadmeat/x_interfaces/monde/zones/45.png" },
		{ id:"santa_icon", src:"http://www.transformice.com/images/x_deadmeat/x_interfaces/monde/zones/46.png" },
		{ id:"mazon_icon", src:"http://www.transformice.com/images/x_deadmeat/x_interfaces/monde/zones/10.png" },
		{ id:"mall_icon", src:"http://www.transformice.com/images/x_deadmeat/x_interfaces/monde/zones/11.png" },
	], _onMapSelectionLoad);
}

function _onMapSelectionLoad() {
	curScreen.dispose();
	curScreen = new MapSelectionScreen();
}

let dt, lastTime = 0;
function update(time) { dt = (time-lastTime)/1000; lastTime = time;
	ctx.clearRect(0, 0, canvas.width, canvas.height);
	curScreen.update(dt);
	spriteManager.update(dt);
	window.requestAnimationFrame(update);
}

var mapDatas = {
	sac: { mapAsset:"sac", spawnX:652, spawnY:611, spawnTileX:118, spawnTileY:110, loadList:[ "images/sac.png" ], scale:0.11 },
}

/////////////////////////////
// Screens
/////////////////////////////
class Screen
{
	constructor() {
		this._addEventListeners();
		this._buildScreen.apply(this, arguments);
	}
	_buildScreen() {
		
	}
	_addEventListeners() { } // Override
	_removeEventListeners() { } // Override
	dispose() {
		this._removeEventListeners();
	}
	update(dt) {
		
	}
}

class PreloadScreen extends Screen
{
	_buildScreen() {
		// this.spinner = spriteManager.add(new FillSprite({ color:"lightgreen", width:50, height:50, x:STAGE_CENTER_X, y:STAGE_CENTER_Y }));
		// this.spinner.add(new FillSprite({ color:"lightgreen", width:50, height:50, rotation:45 }));
		this.spinner = spriteManager.add(new Sprite({ x:STAGE_CENTER_X, y:STAGE_CENTER_Y }));
		this.spinner.add(new FillSprite({ color:"lightgreen", width:10, height:80, rotation:45 }));
		this.spinner.add(new FillSprite({ color:"lightgreen", width:10, height:80, rotation:90 }));
		this.spinner.add(new FillSprite({ color:"lightgreen", width:10, height:80, rotation:135 }));
		this.spinner.add(new FillSprite({ color:"lightgreen", width:10, height:80, rotation:180 }));
	}
	update(dt){
		super.update(dt);
		this.spinner.rotation += 90 * dt;
	}
	dispose(){
		super.dispose();
		spriteManager.clear();
	}
}

class MapSelectionScreen extends Screen
{
	_buildScreen(){
		let tray = spriteManager.add(new FillSprite({ color:"green", width:STAGE_WIDTH*0.8, height:STAGE_HEIGHT*0.8, x:STAGE_CENTER_X, y:STAGE_CENTER_Y }));
		let tLocations = [ "sac", "bodega", "santa", "mazon", "mall" ], tSpacing = 55, tBtn;
		for(var i = 0; i < tLocations.length; i++) {
			tBtn = tray.add(new ButtonImageSprite({ asset:tLocations[i]+"_icon", x:-((tLocations.length*0.5-0.5)*tSpacing) + tSpacing*i }));
			(function(self, pName){ tBtn.onClick.add(() => { self.onMapSelected(pName); }); })( this, tLocations[i] );
		}
	}
	dispose(){
		spriteManager.clear();
	}
	update(dt){
		
	}
	
	onMapSelected(pName) {
		this.loadMap(mapDatas[pName]);
	}
	
	loadMap(pMapData) {
		assets.load(pMapData.loadList, ()=>{
			curScreen.dispose();
			curScreen = new MapScreen(pMapData);
		});
	}
}

class MapScreen extends Screen
{
	_buildScreen(pData) {
		this.data = pData;
		this.map = spriteManager.add(new ImageSprite({ asset:this.data.mapAsset, origin:0 }).to(STAGE_CENTER_X-this.data.spawnX, STAGE_CENTER_Y-this.data.spawnY));
		this._clampMapToSides();
		this.coords = spriteManager.add(new FillSprite({ color:0, width:90, height:35, alpha:0.5, originX:1, originY:0, x:STAGE_WIDTH, y:0 }));
		this.coords = spriteManager.add(new TextSprite({ originX:1, originY:0, x:STAGE_WIDTH-15, y:23 }));
		this.tileWidth = TILE_WIDTH * this.data.scale;
		this.tileHeight = TILE_HEIGHT * this.data.scale;
		this.tileDiag = TILE_DIAG * this.data.scale;
	}
	_addEventListeners() {
		Mouse.onMouseDown.add(this._onMouseDownBinded = this._onMouseDown.bind(this));
		Mouse.onMouseMove.add(this._onMouseMoveBinded = this._onMouseMove.bind(this));
	}
	_removeEventListeners() {
		Mouse.onMouseMove.remove(this._onMouseMoveBinded);
		Mouse.onMouseDown.remove(this._onMouseDownBinded);
	}
	dispose() {
		
	}
	update(dt){
		
	}
	_onMouseDown() {
		this.mouseDownX = Mouse.mouseX;
		this.mouseDownY = Mouse.mouseY;
		this.mapDragX = this.map.x;
		this.mapDragY = this.map.y;
	}
	_onMouseMove() {
		if(Mouse.flagMouseDown) {
			this.map.to( this.mapDragX + (Mouse.mouseX - this.mouseDownX), this.mapDragY + (Mouse.mouseY - this.mouseDownY) );
			this._clampMapToSides();
		}
		if(this.coords) {
			// let tTileX = this.data.spawnTileX + Math.floor((-this.map.x+Mouse.mouseX - this.data.spawnX) / (this.tileWidth*0.5));
			// let tTileY = this.data.spawnTileY + Math.floor((-this.map.y+Mouse.mouseY - this.data.spawnY) / (this.tileHeight*0.5));
			
			let tDistX = (-this.map.x+Mouse.mouseX - this.data.spawnX);
			let tDistY = (-this.map.y+Mouse.mouseY - this.data.spawnY);
			let tLineAngle = Math.atan2(tDistY, tDistX) * RAD2DEG;
			let tDistToTarget = Math.sqrt( tDistX*tDistX + tDistY*tDistY );// * this.data.scale;
			
			// With a triangle using distance between spawn and y coord angle, find number of y tiles away from spawn.
			let tAngleBetweenLineAndTileAngle = tLineAngle - TILE_ANGLE;
			let sideH = tDistToTarget, sideA, sideB,
			angleH = 90, angleA = tAngleBetweenLineAndTileAngle, angleB = (180 - angleH - angleA);
			angleH *= DEG2RAD; angleA *= DEG2RAD; angleB *= DEG2RAD;
			sideA = (sideH/Math.sin(angleH)) * Math.sin(angleA);// * this.data.scale;
			sideB = (sideH/Math.sin(angleH)) * Math.sin(angleB);// * this.data.scale;
			let tYDist = sideA;
			
			// With a triangle using distance between spawn and x coord angle, find number of x tiles away from spawn.
			tAngleBetweenLineAndTileAngle = tLineAngle - TILE_ANGLE2;
			sideH = tDistToTarget, sideA, sideB,
			angleH = 90, angleA = tAngleBetweenLineAndTileAngle, angleB = (180 - angleH - angleA);
			angleH *= DEG2RAD; angleA *= DEG2RAD; angleB *= DEG2RAD;
			sideA = (sideH/Math.sin(angleH)) * Math.sin(angleA);// * this.data.scale;
			sideB = (sideH/Math.sin(angleH)) * Math.sin(angleB);// * this.data.scale;
			let tXDist = sideA;
			
			console.log("Tiles away from spawn:", tXDist, tYDist);
			let tTileX = this.data.spawnTileX + Math.floor(tXDist / (this.tileDiag));//sideB / (this.tileDiag));
			let tTileY = this.data.spawnTileY + Math.floor(tYDist / (this.tileDiag));//sideA / (this.tileDiag));
			this.coords.text = `${tTileX}, ${tTileY}`;
			this.coords.updateFont();
		}
	}
	_clampMapToSides() {
		this.map.x = Utils.clamp(this.map.x, -(this.map.width - STAGE_WIDTH), 0);
		this.map.y = Utils.clamp(this.map.y, -(this.map.height - STAGE_HEIGHT), 0);
	}
	_loopAngle(pAngle, pMax=360) {
		if(pAngle < 0) { return this._loopAngle(pAngle+pMax); }
		else if(pAngle > pMax) { return this._loopAngle(pAngle-pMax); }
		return pAngle;
	}
}

/////////////////////////////
// General
/////////////////////////////
class ConstantsApp {}
ConstantsApp.VERSION = "1.0";

class FewfEvent
{
	constructor() {
		this._list = [];
	}
	add(pCallback) {
		if(this._list.indexOf(pCallback) <= 0) {
			this._list.push(pCallback);
		}
	}
	remove(pCallback) {
		for (var i = this._list.length; 0 < i--;)
			if (this._list[i] == pCallback) {
				this._list.splice(i, 1);
				break
			}
	}
	dispatch() {
		for (var i = 0; i < this._list.length; i++) {
			this._list[i].apply(null, arguments);
		}
	}
	dispose() {
		for (; 0 < this._list.length;) this._list.pop();
		this._list = null
	}
}

class Utils
{
	static clamp(pVal, pMin, pMax) {
		return Math.min(Math.max(pVal, pMin), pMax);
	}
}

class Mouse
{
	static init() {
		Mouse.mouseX = -1000;
		Mouse.mouseY = -1000;
		Mouse.flagMouseDown = false;
		window.addEventListener("mousemove", Mouse._onmousemove);
		canvas.addEventListener("mouseout", Mouse._onmouseout);
		canvas.addEventListener("click", Mouse._onClick);
		canvas.addEventListener("mousedown", Mouse._onmousedown);
		window.addEventListener("mouseup", Mouse._onmouseup);
		
		Mouse.onMouseMove = new FewfEvent();
		Mouse.onClick = new FewfEvent();
		Mouse.onMouseDown = new FewfEvent();
		Mouse.onMouseUp = new FewfEvent();
	}
	
	static _onmousemove(e) {
		Mouse.mouseX = e.pageX - canvas.offsetLeft;
		Mouse.mouseY = e.pageY - canvas.offsetTop;
		if(!Mouse.flagMouseDown) {
			Mouse.mouseX = Utils.clamp(Mouse.mouseX, 0, STAGE_WIDTH);
			Mouse.mouseY = Utils.clamp(Mouse.mouseY, 0, STAGE_HEIGHT);
		}
		Mouse.onMouseMove.dispatch();
	}
	
	static _onmouseout(e) {
		// Mouse.mouseX = -1000, Mouse.mouseY = -1000;
		Mouse.onMouseMove.dispatch();
	}
	
	static _onClick(e) {
		Mouse.onClick.dispatch();
	}
	
	static _onmousedown(e) {
		Mouse.flagMouseDown = true;
		Mouse.onMouseDown.dispatch();
	}
	
	static _onmouseup(e) {
		if(!Mouse.flagMouseDown) { return; }
		Mouse.flagMouseDown = false;
		Mouse.onMouseUp.dispatch();
	}
}
Mouse.init();

class AssetManager
{
	constructor() {
		this._loadingCount = 0;
		this.files = {};
	}
	
	load(pArray, pCallback) {
		for(var i = 0; i < pArray.length; i++) {
			this._loadImage(pArray[i], pCallback);
		}
	}
	
	_loadImage(pSource, pCallback){
		let tFileID = null, tFilePath = pSource, tName, tType;
		if(pSource.id) { tFileID = pSource.id; tFilePath = pSource.src; }
		if(tFilePath.indexOf("/") > -1) {
			[, tName, tType] = /(?:\/+)(?!.*\/)(.*)\.(.*)/g.exec(tFilePath);
		} else {
			[tName, tType] = tFilePath.split(".");
		}
		tFileID = tFileID || tName;
		this._loadingCount++;
		let tImage = new Image();
		tImage.src = tFilePath;
		tImage.onload = (e)=>{
			this._loadingCount--;
			// console.log("(_loadImage)", tName, tType);
			this.files[tFileID] = { id:tFileID, name:tName, asset:tImage, width:tImage.width, height:tImage.height };
			tImage = null;
			if(this._loadingCount == 0) { pCallback(); }
		};
	}
}

/////////////////////////////
// Display
/////////////////////////////
class SpriteManager
{
	constructor() {
		this.sprites = [];
	}
	
	dispose() {
		for(var i = this.sprites.length-1; i >= 0; i--) {
			this.sprites[i].dispose();
			this.sprites[i] = null;
		}
		sprites = null;
	}
	
	add(pSprite) {
		this.sprites.push(pSprite);
		return pSprite;
	}
	
	clear() {
		for(var i = 0; i < this.sprites.length; i++) {
			this.sprites[i].doDelete = true;
		}
	}
	
	update(dt) {
		let tFlagDelete = false;
		// Draw - reverse order to have newest on top.
		// for(var i = this.sprites.length-1; i >= 0; i--) {
		for(var i = 0; i < this.sprites.length; i++) {
			this.sprites[i].update(dt);
			this.sprites[i].draw(ctx);
			if(this.sprites[i].doDelete) { tFlagDelete = true; }
		}
		if(tFlagDelete) {
			for(var i = this.sprites.length-1; i >= 0; i--) {
			if(this.sprites[i].doDelete) {
				this.sprites[i].dispose();
				this.sprites[i] = null;
				this.sprites.splice(i, 1);
			}
		}
		}
	}
}

class Sprite
{
	constructor(pProp) {
		this.children = [];
		this.parent = null;
		this.doDelete = false;
		
		this.x = pProp.x || 0;
		this.y = pProp.y || 0;
		this.alpha = pProp.alpha != null ? pProp.alpha : 1;
		this.rotation = pProp.rotation || 0;
		
		this.scale = pProp.scale != null ? pProp.scale : 1;
		this.scaleX = pProp.scaleX != null ? pProp.scaleX : this.scale;
		this.scaleY = pProp.scaleY != null ? pProp.scaleY : this.scale;
		
		this.origin = pProp.origin != null ? pProp.origin : 0.5;
		this.originX = pProp.originX != null ? pProp.originX : this.origin;
		this.originY = pProp.originY != null ? pProp.originY : this.origin;
	}
	
	dispose() {
		for(var i = this.children.length-1; i >= 0; i--) {
			this.children[i].dispose();
			this.children[i] = null;
		}
		this.children = null;
		this.parent = null;
	}
	
	get scale() { return this.scaleX; }
	set scale(pVal) { this.scaleX = this.scaleY = pVal; }
	
	get origin() { return this.originX; }
	set origin(pVal) { this.originX = this.originY = pVal; }
	
	get width() { return 0; } // Override
	get height() { return 0; } // Override
	
	to(pX, pY) {
		this.x = pX;
		this.y = pY;
		return this;
	}
	
	add(pSprite) {
		this.children.push(pSprite);
		pSprite.parent = this;
		return pSprite;
	}
	
	update(dt) {
		// Override
		for(var i = 0; i < this.children.length; i++) {
			this.children[i].update(dt);
		}
	}
	
	_getDrawX() { return (this.parent != null ? this.parent._getDrawX() : 0) + this.x; }
	_getDrawY() { return (this.parent != null ? this.parent._getDrawY() : 0) + this.y; }
	_getDrawRotation() { return (this.parent != null ? this.parent._getDrawRotation() : 0) + this.rotation; }
	
	draw(ctx) {
		ctx.save();
		this._drawSetup(ctx);
		ctx.restore();
		this._drawChildren(ctx);
	}
	
	_customDraw(ctx) {
		// Override
	}
	
	_drawChildren(ctx) {
		// for(var i = this.children.length-1; i >= 0; i--) {
		for(var i = 0; i < this.children.length; i++) {
			this.children[i].draw(ctx);
		}
	}
	
	_drawSetup(ctx) {
		ctx.globalAlpha = this.alpha;
		ctx.translate(this._getDrawX(), this._getDrawY());
		ctx.rotate(this._getDrawRotation()*Math.PI/180);
		ctx.translate(-this._getDrawX() - this.width*this.scaleX*this.originX, -this._getDrawY() - this.height*this.scaleY*this.originY);
		this._customDraw(ctx);
	}
}

class ImageSprite extends Sprite
{
	constructor(pProp) {
		super(pProp);
		this.file = assets.files[pProp.asset];
	}
	
	dispose() {
		super.dispose();
		this.file = null;
	}
	
	get width() { return this.file.width; }
	get height() { return this.file.height; }
	
	_customDraw(ctx) {
		// ctx.save();
		// this._drawSetup(ctx);
		ctx.drawImage(this.file.asset, this._getDrawX(), this._getDrawY(), this.width*this.scaleX, this.height*this.scaleY);
		// ctx.restore();
		// this._drawChildren(ctx);
	}
}

class ButtonImageSprite extends ImageSprite
{
	constructor(pProp) {
		super(pProp);
		
		this.onClick = new FewfEvent();
		
		Mouse.onClick.add(this._onClickBinded = this._onClick.bind(this));
	}
	
	dispose() {
		super.dispose();
		this.onClick.dispose();
		this.onClick = null;
		
		Mouse.onClick.remove(this._onClickBinded);
	}
	
	update(dt) {
		this.scale = this.containsMouse() ? 1.1 : 1;
	}
	
	containsMouse() {
		return Math.abs(Mouse.mouseX - this._getDrawX()) <= this.width*0.5 && Math.abs(Mouse.mouseY - this._getDrawY()) <= this.height*0.5;
	}
	
	_onClick() {
		if(this.containsMouse()) {
			this.onClick.dispatch();
		}
	}
}

class TextSprite extends Sprite
{
	constructor(pProp) {
		super(pProp);
		this.text = pProp.text || "";
		this.color = pProp.color || "white";
		this.fontName = pProp.fontName || "Arial";
		this.fontSize = pProp.fontSize || "16";
		this.fontStyle = pProp.fontStyle || "bold";
		this.sizeX = this.sizeY = 0;
		this.updateFont();
	}
	
	dispose() {
		super.dispose();
	}
	
	get width() { return this.sizeX; }
	get height() { return this.sizeY; }
	
	updateFont() {
		this.font = `${this.fontStyle} ${this.fontSize * this.scale}px ${this.fontName}`;
		ctx.save();
		ctx.font = this.font;
		this.sizeX = ctx.measureText(this.text).width;
		this.sizeY = this.fontSize;
		ctx.restore();
	}
	_customDraw(ctx) {
		ctx.fillStyle = this.color;
		ctx.font = this.font;
		ctx.fillText(this.text, this._getDrawX(), this._getDrawY());
	}
}

class FillSprite extends Sprite
{
	constructor(pProp) {
		super(pProp);
		this.color = pProp.color;
		this.sizeX = pProp.width;
		this.sizeY = pProp.height;
	}
	
	dispose() {
		super.dispose();
	}
	
	get width() { return this.sizeX; }
	get height() { return this.sizeY; }
	
	_customDraw(ctx) {
		// ctx.save();
		// this._drawSetup(ctx);
		ctx.fillStyle = this.color;
		ctx.fillRect(this._getDrawX(), this._getDrawY(), this.width*this.scaleX, this.height*this.scaleY);
		// ctx.restore();
		// this._drawChildren(ctx);
	}
}

main();

})();
</script>
</body>
